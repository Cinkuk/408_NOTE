#include <iostream>
#include <queue>

typedef char type;

typedef struct BiTNode {
    type data;                       // 数据域
    struct BiTNode *lchild, *rchild; // 左右孩子指针
} BiTNode, *BiTree;

typedef struct ThreadNode {
    type data;                          // 数据域
    struct ThreadNode *lchild, *rchild; // 左右孩子指针
    int ltag, rtag;                     // 标志位
} ThreadNode, *ThreadTree;

// 创建节点函数. generated by DeepSeek.
BiTNode* createNode(char data) {
    BiTNode* newNode = new BiTNode();
    newNode->data = data;
    newNode->lchild = nullptr;
    newNode->rchild = nullptr;
    return newNode;
}

// 构建指定的二叉树. generated by DeepSeek.
BiTree createTree() {
    // 创建所有节点
    BiTNode* A = createNode('A');
    BiTNode* B = createNode('B');
    BiTNode* C = createNode('C');
    BiTNode* D = createNode('D');
    BiTNode* E = createNode('E');
    BiTNode* F = createNode('F');
    BiTNode* G = createNode('G');
    BiTNode* H = createNode('H');
    BiTNode* I = createNode('I');
    
    // 构建树结构
    // A 的左孩子是 B，右孩子是 C
    A->lchild = B;
    A->rchild = C;
    
    // B 的左孩子是 D，右孩子是 E
    B->lchild = D;
    B->rchild = E;
    
    // C 的左孩子是 F，右孩子是 G
    C->lchild = F;
    C->rchild = G;
    
    // F 的左孩子是 H，右孩子是 I
    F->lchild = H;
    F->rchild = I;
    
    return A; // 返回根节点
}

void PreOrder(BiTree);
void InOrder(BiTree);
void PostOrder(BiTree);
void LayerOrder(BiTree);
void visit(BiTNode *);
void visit(ThreadNode *);
void InThread(ThreadTree &, ThreadTree &);
void CreateInThread(ThreadTree &);
void PreThread(ThreadTree &, ThreadTree &);
void CreatePreThread(ThreadTree &);
void PostThread(ThreadTree &, ThreadTree &);
void CreatePOstThread(ThreadTree &);
ThreadNode* InFirstNode(ThreadTree);
ThreadNode* InNextNode(ThreadNode *);
ThreadNode* InPrevNode(ThreadNode *);
void InOrder(ThreadTree);
ThreadNode* PreFirstNode(ThreadTree);
ThreadNode* PreNextNode(ThreadNode *);
ThreadNode* PrePrevNode(ThreadNode *);
void PreOrder(ThreadTree);
ThreadNode* postFirstNode(ThreadTree);
ThreadNode* PostNextNode(ThreadNode *);
ThreadNode* PostPrevNode(ThreadNode *);
void PostOrder(ThreadTree);

int main()
{
    BiTree Tree = createTree();
    PreOrder(Tree);
    std::cout << std::endl;
    InOrder(Tree);
    std::cout << std::endl;
    PostOrder(Tree);
    std::cout << std::endl;
    LayerOrder(Tree);
    std::cout << std::endl;
    return 0;
}

// 访问节点
void visit(BiTNode *node)
{
    std::cout << node->data << " ";
}

void visit(ThreadNode *node)
{
    std::cout << node->data << " ";
}


// 先序遍历
void PreOrder(BiTree T)
{
    if (!T) return ; // empty node
    visit(T);
    PreOrder(T->lchild);
    PreOrder(T->rchild);
}

// 中序遍历
void InOrder(BiTree T)
{
    if (!T) return ; // empty node
    InOrder(T->lchild);
    visit(T);
    InOrder(T->rchild);
}

// 后序遍历
void PostOrder(BiTree T)
{
    if (!T) return ; // empty node
    PostOrder(T->lchild);
    PostOrder(T->rchild);
    visit(T);
}

// 层序遍历
void LayerOrder(BiTree T)
{
    std::queue<BiTNode*> q;
    q.push(T);
    while (!q.empty()){
        if (q.front()->lchild) q.push(q.front()->lchild);
        if (q.front()->rchild) q.push(q.front()->rchild);
        visit(q.front());
        q.pop();
    }
}

// 中序线索化
void InThread(ThreadTree &p, ThreadTree &pre)
{
    InThread(p->lchild, pre); // 递归线索化左子树
    if (!p->lchild) { // 无左孩子, 指向前驱
        p->lchild = pre;
        p->ltag = 1;
    }
    if (pre && !pre->rchild) { // 前驱右孩子为空, 指向当前结点
        pre->rchild = p;
        pre->rtag = 1;
    }
    pre = p; // 更新上一个访问结点指针
    InThread(p->rchild, pre); // 递归线索化右子树
}

// 中序线索化主过程
void CreateInThread(ThreadTree &T)
{
    ThreadNode *pre = nullptr;
    if (T) {
        InThread(T, pre);
        pre->rchild = nullptr; // 最后一个结点必无右孩子, 特别处理
        pre->rtag = 1;
    }
}


// 先序线索化
void PreThread(ThreadTree &p, ThreadTree &pre)
{
    if (!p->lchild) { // 无左孩子, 指向前驱
        p->lchild = pre;
        p->ltag = 1;
    }
    if (pre && !pre->rchild) { // 前驱右孩子为空, 指向当前
        pre->rchild = p;
        pre->rtag = 1;
    }
    pre = p; // 更新指针
    if (p->ltag == 0) PreThread(p->lchild, pre); // 检查线索标志位
    if (p->rtag == 0) PreThread(p->rchild, pre); // 检查线索标志位
}

// 先序线索化主过程
void CreatePreThread(ThreadTree &T)
{
    ThreadNode *pre = nullptr;
    if (T) {
        PreThread(T, pre);
        pre->rchild = nullptr; // 最后一个结点必无右孩子, 特别处理
        pre->rtag = 1; 
    }
}

// 后序线索化
void PostThread(ThreadTree &p, ThreadTree &pre)
{
    PostThread(p->lchild, pre);
    PostThread(p->rchild, pre);
    if (!p->lchild) { // 无左孩子, 指向前驱
        p->lchild = pre;
        p->ltag = 1;
    }
    if (pre && !pre->rchild) { // 前驱无右孩子, 指向当前
        pre->rchild = p;
        pre->rtag = 1;
    }
    pre = p;
}

// 后序线索化主过程
void CreatePOstThread(ThreadTree &T)
{
    ThreadNode *pre = nullptr;
    if (T) {
        PostThread(T, pre); // 后序遍历最后一个结点是根节点, 不用特别处理
    }
}

// 中序序列第一个结点
ThreadNode* InFirstNode(ThreadTree p)
{
    if (!p) return nullptr;
    // 寻找最左下结点
    while (p->ltag == 0) p = p->lchild;
    return p;
}

// 中序后继
ThreadNode* InNextNode(ThreadNode *p)
{
    if (!p) return nullptr;
    if (p->rtag == 0) return InFirstNode(p->rchild);
    return p->rchild;
}

// 中序前驱
ThreadNode* InPrevNode(ThreadNode *p)
{
    if (!p) return nullptr;
    if (p->ltag == 1) return p->lchild;
    p = p->lchild; // 左子树的最右下结点
    while (p->rtag == 0) p = p->rchild;
    return p;
}

// 中序遍历
void InOrder(ThreadTree T)
{
    ThreadNode *p = InFirstNode(T);
    while (p) {
        visit(p);
        p = InNextNode(p);
    }
}


ThreadNode* PreFirstNode(ThreadTree);
ThreadNode* PreNextNode(ThreadNode *);
ThreadNode* PrePrevNode(ThreadNode *);
void PreOrder(ThreadTree);
ThreadNode* postFirstNode(ThreadTree);
ThreadNode* PostNextNode(ThreadNode *);
ThreadNode* PostPrevNode(ThreadNode *);
void PostOrder(ThreadTree);