\documentclass[../../DS]{subfiles}

\begin{document}
\begin{sloppy}
\section{树}
    \textbf{树}: n个结点的有限集; \textbf{空树}: n=0; 任何一个非空树有且仅有一个\textbf{根}. \\
    树的定义是 \textbf{递归}的; 树的根节点没有前驱, 其余结点有且仅有一个前驱; 树中所有结点都可以有零个或多个后继. 树用于表示具有\textbf{层次结构}的数据.

    \textbf{基本术语} \\
    \textbf{祖先}: 结点K的祖先是从根节点到K路径上所有其他结点; \textbf{子孙}: A是B的祖先, B是A的子孙; \textbf{双亲}: 全部祖先中最接近结点的祖先; \textbf{孩子}: A是B的祖先, B是A的孩子; \textbf{兄弟}: 具有相同双亲的结点; \textbf{堂兄弟}: 双亲在同一层的结点(一般用于指代有几个结点在同一层) \\
    \textbf{结点的层次}: 根节点是第1层, 其孩子是第2层, 从上往下数以此类推; \textbf{结点的深度}: 结点所在的层次; \textbf{树的高度(深度)}: 树中结点的最大层数; \textbf{结点的高度}: 以该节点为根节点的子树的高度(从下往上数) \\
    \textbf{结点的度}: 一个结点的孩子个数; \textbf{树的度}: 树中结点的最大度数 \\
    \textbf{分支节点(非终端结点)}: 度大于0的结点; \textbf{叶子结点(终端结点)}: 度为0的结点 \\
    \textbf{有序树}: 树中各个结点的各个子树从左到右有次序, 不能互换; \textbf{无序树}: 树中结点的各子树可以互换左右次序 \\
    \textbf{路径}: 由两个结点之间经过的结点序列(EX. A到B的路径A->C->D->B). 只能从上到下, 有向边. \textbf{路径长度}: 路径上所经过的边的个数; \textbf{树的路径长度}: 分为 \textbf{内部路径长度IPL}: 所有结点的深度之和; 和 \textbf{外部路径长度}: 所有叶子结点的深度之和

    \textbf{数值特征}: 

    \textbf{度为m的树与m叉树} \\
    \textbf{度为m的树}: 任意结点的度$\leq m$, \textbf{至少一个}结点的度为m \\
    \textbf{m叉树}: 任意结点的度$\leq m$, 允许所有结点的度$< m$, 可以是空树

    \textbf{树的结点数$n = $所有结点的度数之和 $+1$}

    \textbf{度为$m$的树, 第$i$层上最多有$m^{i-1}\ (i \geq 1)$个结点}. 第一层$1$个, 第2层$m$个, 第3层$m^2$个

    \textbf{高度为$h$的$m$叉树, 至多有$\frac{m^h - 1}{m - 1}$个结点}. $m^0 + m^1 + \dots + m^h = \frac{1 - m^h }{1 - m}$

    \textbf{度为$m$, 具有$n$个结点的树的最小高度为$\lceil \log_m{[n(m-1)+1]} \rceil$}. 前h-1层最大, 共$\frac{m^{h-1} - 1}{m - 1}$ \\
    因此$\frac{m^{h-1} - 1}{m - 1} < n \leq \frac{m^{h} - 1}{m - 1},\ h-1 < \log_m{[n(m-1) + 1]} \leq h$

    \textbf{度为$m$, 共有$n$个结点的最大高度$h$为$n - m + 1$}
    % new two columns
    \begin{center}
    \begin{minipage}[t]{0.48\textwidth}
    \vspace{0pt}
        \begin{forest}
            [A 
                [B 
                    [C] [D] [\dots]
                ]
            ]
        \end{forest}
    \end{minipage}
    \begin{minipage}[t]{0.48\textwidth}
    \vspace{0pt}
        \raggedright
        前$h-1$层每层一个, 最后一层$m$个(度为m). $(h - 1) + m = n$
    \end{minipage}
    \end{center}

\newpage
\subsection{二叉树}

    每个结点中至多有两课子树(不存在度>2的结点), 子树有左右之分不可颠倒(有序树).

    \textbf{二叉树与度为2的树的区别}: (a) 二叉树可以\textbf{为空}, 度为2至少有3个结点, 其中一个度为2; (b) 二叉树的左右次序确定, 不可更改; 度为2的树中, 左右次序是相对于另一个孩子而言的, 若只有一个结点, 则不需要区分左右次序

    \textbf{特殊二叉树} \\
    1. \textbf{满二叉树}: 高度为$h$, 具有$2^h - 1$个结点的树. (a) 只有\textbf{度为0和度为2}的结点; (b) 仅最后一层有叶节点; (c) 每层都含有最多的结点; 叶节点集中在最下一层 \\
    \textbf{满二叉树层序编号}: 按照从上到下从左到右从1开始编号: 对于编号为$i$的结点, 双亲为$\lfloor i/2 \rfloor$, 左孩子$2i$, 有孩子$2i+1$ (若有). \\
    2. \textbf{完全二叉树}: 高度为$h$, 有$n$个结点, 每个结点都与高度为$h$的满二叉树中编号为$1 \sim n$的结点一一对应. 可以视为从满二叉树删去若干最底层最靠右的一些连续叶结点. (a) 只有最后\textbf{2层}有叶结点; (b) 最多只有一个\textbf{度为1}的结点; (c) 孩子双亲的编号关系同满二叉树; (d) 编号$i \leq \lfloor n/2 \rfloor$的是分支节点, $i > \lfloor n/2 \rfloor$为叶子结点 \\
    \textbf{完全二叉树推算不同度的结点数}: 记有$n$个结点的二叉树中, 度为0, 1, 2的结点分别有$n_0, n_1, n_2$. 则$n_0 + n_1 + n_2 = n_1 + 2 n_2 + 1, \implies n_0 = n_2 + 1$ \\
    假设二叉树有$n$个结点: \\
    (1) n为奇数, $n = 2k - 1$, 有$n = (n_0 + n_2) + n_1 = (2n_2 + 1) + n_1,\ \implies n_1 = 0, n_2 = k - 1, n_0 = k$ \\
    (2) n为偶数, $n = 2k$, $n = (2 n_2 + 1) + n_1 \implies n_1 = 1, n_2 = k - 1, n_0 = k$ \\
    3. \textbf{二叉排序树}: 对任意一个结点, 其左子树上所有结点的关键字小于自身关键字, 其右子树上所有结点的关键字大于自身关键字. 其左右子树亦是一颗二叉排序树 \\
    4. \textbf{平衡二叉树}: 树中任意一个结点的左右子树的高度差的绝对值不超过1 \\
    5. \textbf{正则二叉树}: 只有度为0或2的结点

    \textbf{数值性质} \\
    1. $n_0 = n_2 + 1$ \\
    2. 非空二叉树第$k$层最多有$2^{k-1}$个结点$(k \geq 1)$ \\
    3. 高度为$h$的二叉树最多有$2^h - 1$个结点$(h \geq 1)$ \\
    4. 具有$n(n > 0)$个结点的\textbf{完全二叉树}, 高度为$\lfloor \log_2 n \rfloor + 1$或$\lceil \log_2 (n+1) \rceil$ \\
    5. 对\textbf{完全二叉树}从\textbf{1}开始, 从上到下, 从左到右开始编号. 对于编号为$i$的结点: \\
    (a) 双亲$\lfloor i/2 \rfloor$, 左孩子$2i$, 右孩子$2i + 1$ \\
    (b) 最后一个分支节点$\lfloor n/2 \rfloor$, 若$i < \lfloor n/2 \rfloor$为分支结点, 否则为叶结点 \\
    (c) 若有度为1的结点, 只可能是最后一个分支结点$\lfloor n/2 \rfloor$, 且该结点只有左孩子没有右孩子 \\
    (d) 层序编号后, 若某节点为叶结点或只有左孩子, 则编号大于该结点的结点均为叶结点 \\
    (e) 结点$i$所在层次是$\lfloor \log_2 i \rfloor + 1$或者$\lceil \log_2 (i+1) \rceil$. ($2^{h-1} -1 + 1 \leq i \leq 2^h - 1 < 2^h$或$2^{h-1} - 1 < i \leq 2^h - 1$) \\
    6. 对\textbf{完全二叉树}从\textbf{0}开始, 从上到下, 从左到右开始编号. 对于编号为$i$的结点: (编号为$i$的结点, 对应从1开始编号是编号为$i+1$的结点, 代换)\\
    (a) 双亲$\lfloor \frac{i-1}{2} \rfloor$, 左孩子$2 i + 1$, 右孩子$2 i + 2$ \\
    (b) 最后一个分支节点$\lfloor n/2 \rfloor - 1$, 若$i < \lfloor n/2 \rfloor - 1$为分支结点, 否则为叶结点 \\
    (c) 若有度为1的结点, 只可能是最后一个分支结点$\lfloor n/2 \rfloor - 1$, 且该结点只有左孩子没有右孩子 \\
    (d) 层序编号后, 若某节点为叶结点或只有左孩子, 则编号大于该结点的结点均为叶结点 \\
    (e) 结点$i$所在层次是$\lfloor \log_2 (i + 1)\rfloor + 1$或者$\lceil \log_2 (i+2) \rceil$.

\subsubsection{存储结构}

    \textbf{顺序存储}

    对于\textbf{完全二叉树}或者\textbf{满二叉树}, 适合使用\textbf{顺序存储}. 树中结点的序号可以唯一地表示结点之间的逻辑关系. 

    顺序存储结构中, 需要在数组元素结构体中新增bool成员表示该结点是否为空. 对于任意一棵二叉树, 按照顺序存储时, 需要对照相同高度的完全二叉树在没有结点的地方添加空结点, 会造成存储空间浪费. 最坏情况下, $n$个结点的单支树, 需要占用$2^n - 1$个存储空间. 

    \textbf{判断是否有孩子}: 计算在若为完全二叉树的情况下, 该结点所在位置的编号$i$以及孩子编号, 再利用bool类型成员查询孩子编号的数组元素是否为空元素
    
    \textbf{链式存储}

    一般采用链式存储. 一般分为不带双亲指针的二叉链表和带双亲指针(指向双亲)的三叉链表. 对于$n$个结点的链表, 有$2n$个指针域, 只有$n-1$个结点被指向, 因此有$n+1$个空链域 (用于组成线索二叉树)

    \begin{lstlisting}[style = Cpp]
    typedef struct BiTNode {
        type data;                       // 数据域
        struct BiTNode *lchild, *rchild; // 左右孩子指针
    } BiTNode, *BiTree;
    \end{lstlisting}

\subsubsection{二叉树的遍历}

    二叉树遍历是寻找一种方式使得每个结点都被访问一次而且只被访问一次. \textbf{根(N), 左孩子(L), 有孩子(R)}. 常见的遍历有: 先序遍历(先根遍历), 中序遍历(中根遍历), 后序遍历(后根遍历), 层序遍历. 先中后序遍历使用递归实现, 层序遍历借助队列实现.

    % new two columns
    \begin{center}
    \begin{minipage}[t]{0.48\textwidth}
    \vspace{0pt}
        \begin{forest}
        [A 
            [B 
                [D] [E]
            ]
            [C 
                [F 
                    [H][I]
                ] [G]
            ]
        ]
        \end{forest}
    \end{minipage}
    \begin{minipage}[t]{0.48\textwidth}
    \vspace{0pt}
        先序遍历NLR: A B D E C F H I G

        中序遍历LNR: D B E A H F I C G

        后序遍历LRN: D E B H I F G C A

        层序遍历: A B C D E F G H I
    \end{minipage}
    \end{center}

    每个结点均访问一次且只访问一次, \textbf{时间复杂度}: $T(n) = O(n)$; \textbf{空间复杂度}: 空间复杂度与使用的递归工作栈的深度有关, $S(n) = O(h+1) = O(h)$, $h$为树的深度, 在\textbf{最坏情况下}, 树为单支树, 结点数为$n$, 树深度为$n$, 此时$S(n) = O(n)$

    \newpage
    \begin{lstlisting}[style = Cpp]
    // 先序遍历
    void PreOrder(BiTree T)
    {
        if (!T) return ; // empty node
        visit(T);
        PreOrder(T->lchild);
        PreOrder(T->rchild);
    }
    
    // 中序遍历
    void InOrder(BiTree T)
    {
        if (!T) return ; // empty node
        InOrder(T->lchild);
        visit(T);
        InOrder(T->rchild);
    }
    
    // 后序遍历
    void PostOrder(BiTree T)
    {
        if (!T) return ; // empty node
        PostOrder(T->lchild);
        PostOrder(T->rchild);
        visit(T);
    }
    
    // 层序遍历
    void LayerOrder(BiTree T)
    {
        std::queue<BiTNode*> q;
        q.push(T);
        while (!q.empty()){
            if (q.front()->lchild) q.push(q.front()->lchild);
            if (q.front()->rchild) q.push(q.front()->rchild);
            visit(q.front());
            q.pop();
        }
    }
    \end{lstlisting}

\newpage
\subsubsection{由遍历序列重建二叉树}

    只给出四种遍历序列中的任意一种都不能唯一确定二叉树; 给出\textbf{中序遍历序列}和其余任意一种遍历序列, 可以唯一确定一颗二叉树. 关键在于交替使用两个对立确定根节点跟左右子树的结点, 递归逐层重建.

    \textbf{先序和中序}

    先序: ABCDEFGHI; 中序: BCAEDGHFI

    \begin{center}
        % new three columns
        \begin{minipage}[t]{0.32\textwidth}
        \vspace{0pt}
        \begin{center}
            1. root: A, left: BC, right: EDGHFI
            \begin{forest}
            [A 
                [BC][EDGHIF]
            ]
            \end{forest}
        \end{center}
        \end{minipage}
        \begin{minipage}[t]{0.32\textwidth}
        \vspace{0pt}
        \begin{center}
            2. LEFT: root: B, right: C
            
            RIGHT: root: D, left: E, right: GHFI
            \begin{forest}
            [A 
                [B 
                [,draw=none][C]
                ]
                [D 
                [E][GHFI]
                ]
            ]
            \end{forest}
        \end{center}
        \end{minipage}
        \begin{minipage}[t]{0.32\textwidth}
        \vspace{0pt}
        \begin{center}
            \begin{forest}
                [A 
                   [B
                        [,draw=none][C]
                   ]
                   [D
                        [E]
                        [F
                            [G 
                                [,draw=none][H]
                            ]
                            [I]
                        ]
                   ]
                ]
                \end{forest}
        \end{center}
        \end{minipage}
    \end{center}
    
    \textbf{后序和中序}

    后序: CBEHGIFDA, 中序: BCAEDGHFI

    % new three columns
    \begin{center}
    \begin{minipage}[t]{0.48\textwidth}
    \vspace{0pt}
    \begin{center}
        1. root: A, left: BC, right: EDGHFI

        \begin{forest}
        [A 
            [BC][EDGHFI]
        ]
        \end{forest}
    \end{center}
    \end{minipage}
    \begin{minipage}[t]{0.48\textwidth}
    \vspace{0pt}
    \begin{center}
        \begin{forest}
        [A 
           [B 
                [,draw=none][C]
           ]
           [D 
                [E]
                [F 
                    [G
                        [,draw=none] [H]
                    ]
                    [I]
                ]
           ] 
        ]
        \end{forest}
    \end{center}
    \end{minipage}
    \end{center}

    \textbf{层序和中序}

    层序: ABDCEFGIH, 中序: BCAEDGHFI

    % new two columns
    \begin{center}
    \begin{minipage}[t]{0.48\textwidth}
    \vspace{0pt}
    \begin{center}
        1. root: A, left: BC, right: EDGHFI

        \begin{forest}
            [A 
                [BC][EDGHFI]
            ]
        \end{forest}
    \end{center}
    \end{minipage}
    \begin{minipage}[t]{0.48\textwidth}
    \vspace{0pt}
    \begin{center}
        \begin{forest}
            [A 
               [B 
                    [,draw=none][C]
               ]
               [D 
                    [E]
                    [F 
                        [G
                            [,draw=none] [H]
                        ]
                        [I]
                    ]
               ] 
            ]
        \end{forest}
    \end{center}
    \end{minipage}
    \end{center}

\newpage
\subsection{线索二叉树}

    \textbf{结点结构}\ \ \ \ 
    \begin{tabular}{|c|c|c|c|c|}
        \hline
        lchild & ltag & data & rtag & rchild \\
        \hline
    \end{tabular}

    约定tag域的数据: $tag = 
    \begin{cases}
    0, \mbox{指向该结点的孩子} \\
    1, \mbox{指向该结点的前驱或后继}
    \end{cases}$
    
    左孩子指针作为线索指向前驱, 有孩子指针作为线索指向后继

    \begin{lstlisting}[style = Cpp]
    typedef struct ThreadNode { // 线索链表
        type data;                          // 数据域
        struct ThreadNode *lchild, *rchild; // 左右孩子指针
        int ltag, rtag;                     // 标志位
    } ThreadNode, *ThreadTree;
    \end{lstlisting}
    
    \textbf{线索链表}: 含有左右线索标志位的二叉链表; \textbf{线索}: 指向结点前驱和后继的指针; \textbf{线索二叉树}: 加上线索的二叉树

\vspace{-0.5\baselineskip}
\subsubsection{二叉树线索化}

    \vspace{-0.7\baselineskip}
    \textbf{线索化的特别处理} \\
    \textbf{先序线索化}: \textbf{需要预先检查线索标志位避免循环递归}. 当前结点的左右孩子的前驱为当前结点, 在递归线索化中, 如果不预先判断左右孩子指针指向真正孩子还是前驱后继, 当孩子指向前驱时, 会进入死循环. \\
    \textbf{中序线索化}: \textbf{置空遍历过程最后一个结点的右孩子指针}. 最后一个结点必然无右结点, 需要结束线索化后置空. \\
    \textbf{后序线索化}: \textbf{无序特别处理}. 最后一个遍历的结点是根节点.

    \begin{lstlisting}[style = Cpp]
    // 中序线索化
    void InThread(ThreadTree &p, ThreadTree &pre)
    {
        InThread(p->lchild, pre); // 递归线索化左子树
        if (!p->lchild) { // 无左孩子, 指向前驱
            p->lchild = pre;
            p->ltag = 1;
        }
        if (pre && !pre->rchild) { // 前驱右孩子为空, 指向当前结点
            pre->rchild = p;
            pre->rtag = 1;
        }
        pre = p; // 更新上一个访问结点指针
        InThread(p->rchild, pre); // 递归线索化右子树
    }
    
    // 中序线索化主过程
    void CreateInThread(ThreadTree &T)
    {
        ThreadNode *pre = nullptr;
        if (T) {
            InThread(T, pre);
            pre->rchild = nullptr; // 最后一个结点必无右孩子, 特别处理
            pre->rtag = 1;
        }
    }
    \end{lstlisting}

    % new two columns
    \begin{center}
    \begin{minipage}[t]{0.48\textwidth}
    \vspace{0pt}
        \begin{lstlisting}[style = Cpp]
            // 先序线索化
            void PreThread(ThreadTree &p, ThreadTree &pre)
            {
                if (!p->lchild) { // 无左孩子, 指向前驱
                    p->lchild = pre;
                    p->ltag = 1;
                }
                if (pre && !pre->rchild) { // 前驱右孩子为空, 指向当前
                    pre->rchild = p;
                    pre->rtag = 1;
                }
                pre = p; // 更新指针
                if (p->ltag == 0) PreThread(p->lchild, pre); // 检查线索标志位
                if (p->rtag == 0) PreThread(p->rchild, pre); // 检查线索标志位
            }

            // 先序线索化主过程
            void CreatePreThread(ThreadTree &T)
            {
                ThreadNode *pre = nullptr;
                if (T) {
                    PreThread(T, pre);
                    pre->rchild = nullptr; // 最后一个结点必无右孩子, 特别处理
                    pre->rtag = 1; 
                }
            }
        \end{lstlisting}
    \end{minipage}
    \begin{minipage}[t]{0.48\textwidth}
    \vspace{0pt}
        \begin{lstlisting}[style = Cpp]
            // 后序线索化
            void PostThread(ThreadTree &p, ThreadTree &pre)
            {
                PostThread(p->lchild, pre);
                PostThread(p->rchild, pre);
                if (!p->lchild) { // 无左孩子, 指向前驱
                    p->lchild = pre;
                    p->ltag = 1;
                }
                if (pre && !pre->rchild) { // 前驱无右孩子, 指向当前
                    pre->rchild = p;
                    pre->rtag = 1;
                }
                pre = p;
            }

            // 后序线索化主过程
            void CreatePOstThread(ThreadTree &T)
            {
                ThreadNode *pre = nullptr;
                if (T) {
                    PostThread(T, pre); // 后序遍历最后一个结点是根节点, 不用特别处理
                }
            }
        \end{lstlisting}
    \end{minipage}
    \end{center}

    \textbf{带头结点的线索二叉树}: 额外定义一个头结点. 其前驱指向树的根节点, 其后继指向最后一个遍历的结点; 最后一个遍历的结点的右孩子指向头结点, 第一个遍历的结点的左孩子指向头结点. 带头结点的线索二叉树类似于双向循环链表, 允许从树中任一结点开始, 向后或者向前遍历整棵树.

\newpage
\subsubsection{非线索二叉树的遍历}

    \textbf{中序遍历} \\
    \textbf{后继}: 右子树的最左下结点 \\
    \textbf{前驱}: 左子树的最右下结点

    \textbf{先序遍历} \\
    \textbf{后继}: (a) 有左孩子: 左孩子; (b) 无左孩子: 右孩子 \\
    \textbf{前驱}: 需要先找到双亲结点p. \\
    (a) 当前结点为左孩子: p; \\
    (b) 当前为右孩子: (b1) p无左孩子: p ;(b2) p有左孩子: p左子树的最右下结点

    \textbf{后序遍历} \\
    \textbf{后继}: 需要先找到双亲结点p. \\
    (a) 当前是p的左孩子: (a1) 若p有右孩子: p右子树的最左下结点; (a2) p无右孩子: p \\
    (b) 当前是p的右孩子: p \\
    \textbf{前驱}: (a) 有右孩子: 右孩子; (b) 无右孩子: 左孩子
    
\subsubsection{线索二叉树的遍历}

    先序和后序需要寻找双亲结点, 一般使用带双亲指针的三叉链表实现, 在二叉链表中实现复杂, 不予考虑.

    % new two columns
    \begin{center}
    \begin{minipage}[t]{0.48\textwidth}
    \vspace{0pt}
        \begin{lstlisting}[style = Cpp]
        // 中序序列第一个结点
        ThreadNode* InFirstNode(ThreadTree p)
        {
            if (!p) return nullptr;
            // 寻找最左下结点
            while (p->ltag == 0) p = p->lchild;
            return p;
        }
        
        // 中序后继
        ThreadNode* InNextNode(ThreadNode *p)
        {
            if (!p) return nullptr;
            if (p->rtag == 0) return InFirstNode(p->rchild);
            return p->rchild;
        }
        \end{lstlisting}
    \end{minipage}
    \begin{minipage}[t]{0.48\textwidth}
    \vspace{0pt}
        \begin{lstlisting}[style = Cpp]
        // 中序前驱
        ThreadNode* InPrevNode(ThreadNode *p)
        {
            if (!p) return nullptr;
            if (p->ltag == 1) return p->lchild;
            p = p->lchild; // 左子树的最右下结点
            while (p->rtag == 0) p = p->rchild;
            return p;
        }
        
        // 中序遍历
        void InOrder(ThreadTree T)
        {
            ThreadNode *p = InFirstNode(T);
            while (p) {
                visit(p);
                p = InNextNode(p);
            }
        }
        \end{lstlisting}
    \end{minipage}
    \end{center}
    
\subsection{树与森林}

\subsubsection{树的存储结构}

    树能够使用顺序存储结构和链式存储结构, 但必须能够唯一地表示出树中各结点的逻辑关系(由于一棵树的结点数量不确定, 只存储数据不存储逻辑关系, 不能够连接各结点)

    \begin{figure}[htbp]
        \centering
        \includegraphics[width=0.35\columnwidth]{./tree.png} 
    \end{figure}
    
    

    \textbf{双亲表示法}

    \textbf{顺序存储}, 使用一组连续空间来存储每个结点, 在每个结点中设置一个\textbf{伪指针}, 指向\textbf{其双亲结点在数组中的位置}. 根节点的伪指针域为\textbf{-1}.

    在\textbf{存储森林}时, 将每棵树根节点的parent设为-1即可.

    优点: 找双亲快; 缺点: 找孩子不方便, 只能遍历整棵树. 适用于寻找双亲多, 寻找孩子少的情景.

    \begin{lstlisting}[style = Cpp]
    typedef struct {
        type data;      // 数据元素
        int parant;     // 伪指针, 指向双亲
    } PTNode;
    
    typedef struct {
        PTNode nodes[MAX_TREE_SIZE];  // 存储结点
        int n;                        // 结点数
    } PTree;
    \end{lstlisting}

    \begin{figure}[htbp]
        \centering
        \includegraphics[width=0.45\columnwidth]{./parent.png}
    \end{figure}
    
    \newpage
    \textbf{孩子表示法}

    混合使用\textbf{顺序存储和链式存储}. 每个结点均存入线性表, 每个结点的直接后继以单链表的形式存在双亲结点之后. n个结点有n个孩子链表, 叶结点的孩子链表为空表. n个头指针组成一个单链表. 

    \textbf{存储森林}时, 需要在将结构体中封装记录全部根节点位置的成员.

    优缺点与双亲相反: 优点: 寻找孩子非常方便; 缺点: 寻找双亲需要遍历n个结点中孩子链表指向的n个孩子链表结点. 适用于寻找孩子多, 寻找双亲少的场景.

    \begin{figure}[htbp]
        \centering
        \includegraphics[width=0.35\columnwidth]{./children.png}
    \end{figure}

    \textbf{孩子兄弟表示法(二叉树表示法)}

    以\textbf{二叉链表}作为树的存储结构. \textbf{结点组成: 结点值, 指向结点第一个孩子的指针, 指向结点下一个兄弟结点的指针}.

    优点: 可以方便实现树转换为二叉树的操作, 易于查找节点的孩子等; 缺点: 从当前结点查找双亲结点比较麻烦. 若增设指向双亲结点的指针parent, 查找双亲结点也会很方便.

    \begin{figure}[htbp]
        \centering
        \includegraphics[width=0.3\columnwidth]{./childbro.png}
    \end{figure}
    
\newpage
\subsubsection{树转换为二叉树}

    \textbf{左孩子, 右兄弟}. 每个结点左指针指向第一个孩子, 右指针指向下一个兄弟. 转换时可以逐层处理以防遗漏.

    \begin{forest}
    [A 
            [B 
                [E][F]
            ]
            [C]
            [D
                [,draw=none][G]
            ]
    ]
    \end{forest}
    $\iff$
    \begin{forest}
    [A 
        [B
            [EF]
            [C 
                []
                [D
                    [G][]
                ]
            ]
        ]
        [,draw=none]
    ]
    \end{forest}
    $\iff$
    \begin{forest}
    [A 
        [B
            [E
                [][F]
            ]
            [C 
                []
                [D
                    [G][]
                ]
            ]
        ]
        [,draw=none]
    ]
    \end{forest}

\subsubsection{森林与二叉树互相转换}

    \textbf{森林转换为二叉树} \\
    (1) 森林中每棵树转换为二叉树 \\
    (2) 每棵树的根视为兄弟关系, 合并二叉树

    \textbf{二叉树转换为森林} \\
    (1) 将根节点和根节点左子树单独取出, 断开右指针. 所取出的部分为第一颗树 \\
    (2) 对剩余部分重复步骤(1), 直到只剩下一颗不存在右子树的二叉树 \\
    (3) 将分离出的二叉树转换为树

    \begin{figure}[htbp]
        \centering
        \begin{subfigure}{0.32\textwidth}
            \begin{forest}
            [A 
                [B][C][D]
            ]
            \end{forest}
            \begin{forest}
            [E 
                [F]
            ]
            \end{forest}
            \begin{forest}
            [G 
                [H][I]
            ]
            \end{forest}
            \caption{森林}
        \end{subfigure}
        \begin{subfigure}{0.32\textwidth}
            \begin{forest}
            [A 
                [B
                        [][C 
                                [][D]
                            ]
                ]
                []
            ]
            \end{forest}
            \begin{forest}
            [E 
                [F][]
            ]
            \end{forest}
            \begin{forest}
            [G 
                [H
                    [][I]
                ]
                []
            ]
            \end{forest}
            \caption{各自转换为二叉树}
        \end{subfigure}
        \begin{subfigure}{0.32\textwidth}
            \begin{forest}
            [A 
                [B
                    [][C 
                        [][D]
                        ]
                ]
                [E 
                    [F]
                    [G
                        [H
                            [][I]
                        ]
                        []
                    ]
                ]
            ]
            \end{forest}
            \caption{合并为二叉树}
        \end{subfigure}
        
    \end{figure}
    
\newpage
\subsubsection{树的遍历}

    \begin{forest}
        [A 
            [B 
                [E][F]
            ]
            [C]
            [D
                [,draw=none][G]
            ]
        ]
    \end{forest}

    \textbf{先根遍历}, 遍历序列与\textbf{二叉树的先序遍历}序列相同 \\
    (1) 访问根节点; \\
    (2) 依照顺序访问每课子树, 子树访问顺序依然为先根后子树

    遍历序列: ABEFCDG

    \textbf{后根遍历}, 遍历序列与\textbf{二叉树的中序遍历}序列相同 \\
    LNR, 全部子树在根节点的左子树; 在根节点的左孩子中, 本身与左子树为第一颗子树, 其第一个右孩子及其左子树为第二颗子树, 其第二个右孩子及其左子树为第三棵树 \dots) \\
    (1) 依次遍历每棵子树, 遍历时遵循先子树后根结点的顺序; \\
    (2) 访问根节点

    遍历序列: EFBCGDA

    \textbf{层次遍历}: 按照层序依次访问各结点

    遍历序列: ABCDEFG

\vspace{-1\baselineskip}
\subsubsection{森林的遍历}

    \begin{forest}
        [A 
            [B][C][D]
        ]
        \end{forest}
        \begin{forest}
        [E 
            [F]
        ]
        \end{forest}
        \begin{forest}
        [G 
            [H][I]
        ]
    \end{forest}

    \textbf{先序遍历森林}, 等同于对每棵树依次进行先根遍历, 或对应二叉树的先序遍历 \\
    (1) 访问森林中第一棵树的根节点; \\
    (2) 先序访问第一棵树中根节点的子树森林; \\
    (3) 先序访问除第一棵树外剩余树构成的森林

    遍历序列: ABCDEFGHI

    \textbf{中序遍历森林}, 等同于对每棵树依次进行后根遍历, 或对应二叉树的中序遍历 \\
    (1) 中序遍历第一棵树根节点的子树森林; \\
    (2) 访问第一棵树的根节点; \\
    (3) 中序遍历除第一棵树外剩余树构成的子树森林

    遍历序列: BCDAFEHIG

    \begin{center}
        \begin{tabular}{|c|c|c|}
            \hline
            树 & 森林 & 对应二叉树 \\
            \hline
            先根遍历 & 先序遍历 & 先序遍历 \\
            \hline
            后根遍历 & 中序遍历 & 中序遍历 \\
            \hline
        \end{tabular}
    \end{center}
    
    
    


    








    
    
    
    








\end{sloppy}
\end{document}