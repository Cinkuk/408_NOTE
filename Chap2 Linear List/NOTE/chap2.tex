\documentclass[../../DS]{subfiles}

\begin{document}
\begin{sloppy}

\section{线性表}
    
    \textbf{线性表}: 具有\textbf{相同}数据类型的n个\textbf{数据元素}的\textbf{有限序列}. 
    
    n为\textbf{表长}, n=0时, 线性表为\textbf{空表}. 将线性表命名为$L$, 表示为$L = (a_1, a_2, \dots, a_i, a_{i+1}, \dots, a_n)$. i为位序, 1-index, 表示\textbf{第i个元素}; 数组索引为0-index
    
    \textbf{表头元素}: $a_1$, \textbf{表尾元素}: $a_n$. 表头元素表尾元素均唯一. 
    
    除第一个元素, 每个元素有且仅有一个直接前驱; 除最后一个元素, 每个元素有且只有一个直接后继. 

    \textbf{线性表的基本操作: 创销增删查改}

    \begin{lstlisting}[style = Cpp]
    Initial(&L) // 初始化表, 创建一个空的线性表
    Length(L) // 求表长. 返回: 表的长度(数据元素个数)
    LocateElem(L, e) // 按值查找. 返回: L中元素e的位序
    GetElem(L, i) // 按位查找. 返回: L中第i个元素
    ListInsert(&L, i, e) // 插入. 将e插入到L的第i个位置
    ListDelete(&L, i, &e) // 删除. 删除L中第i个元素, 并将删除的元素通过e返回
    PrintList(L) // 打印表
    Empty(L) // 判空. 返回: empty -> true; not empty -> false
    DestroyList(&L) // 销毁. 销毁线性表并释放L所占空间
    \end{lstlisting}

\newpage
\subsection{顺序表}

    \textbf{顺序表}: 线性表的顺序存储. 用一组\textbf{地址连续的单元}依次存储线性表中的数据元素. 逻辑上相邻, 物理上相邻. 
    
    \textbf{特点}: 1) 逻辑顺序与物理顺序相同; 2) 可随机存取; 3) 存储密度大; 4) 拓展容量不方便; 5) 插入删除需要移动大量元素, 时间开销大 
    
    \textbf{优点}: 1) 存储密度大; 2) 可以随机访问: 即通过元素首地址和元素序号可以在O(1)时间内找到指定元素

    \textbf{缺点}: 1) 元素的插入和删除需要移动大量元素, 插入平均需要移动$n/2$个元素, 删除平均需要移动$(n-1)/2$个元素; 2) 顺序存储分配需要一段连续的存储空间

    \textbf{结构}

    \begin{lstlisting}[style = Cpp]
    // 静态分配
    typedef struct
    {
        ElemType data[MAXSIZE];
        int maxsize; // 最大长度, 为了方便操作加上, 若保证能访问宏定义MAXSIZE可以省略
        int length; // 当前长度
    }SqList;
    
    // 动态分配
    typedef struct
    {
        ElemType *data;
        int maxsize; // 当前最大长度
        int length; // 当前长度
    }SeqList;
    \end{lstlisting}

    \vspace{-0.5\baselineskip}
    \textbf{初始化表}
    \begin{lstlisting}[style = Cpp]
    // 初始化静态分配顺序表
    void Initial(SqList &L)
    {
        L.maxsize = MAXSIZE;
        L.length = 0;
    }
    
    // 初始化动态分配顺序表
    bool Initial(SeqList &L)
    {
        L.maxsize = MAXSIZE;
        L.length = 0;
        if ((L.data = new Type[MAXSIZE]))
            return true;
        return false;
    }
    \end{lstlisting}

    \newpage
    \textbf{销毁表}
    \begin{lstlisting}[style = Cpp]
    // 销毁动态分配顺序表
    bool DestroyList(SeqList &L)
    {
        L.maxsize = 0;
        L.length = 0;
        delete L.data; // free space
        return true;
    }
    \end{lstlisting}

    \vspace{-0.5\baselineskip}
    \textbf{扩展表}
    \begin{lstlisting}[style = Cpp]
    // 扩展表
    bool IncreaseList(SeqList &L, int n)
    {
        n += L.maxsize; // new data size
        if (Type* new_data = new Type[n]) // try to request space
        {
            for (int i=0; i<L.length; i++) // move elements
                new_data[i] = L.data[i];
            delete L.data; // free space
            L.data = new_data; // change data pointer
            L.maxsize = n; // new data size
            return true;
        }
        else return false;
    }
    \end{lstlisting}

    \vspace{-0.5\baselineskip}
    \textbf{查找}: 按值查找: 最好$O(1)$, 平均/最坏$O(n)$; 按位查找: $O(1)$
    \begin{lstlisting}[style = Cpp]
    // 按值查找
    template <typename T>
    int LocateElem(T L, Type e)
    {
        // return order of elemet
        for (int i=0; i<L.length; i++)
            if (L.data[i] == e) return i+1;
        return -1;
    }
    
    // 按位查找
    template <typename T>
    Type GetElem(T L, int i)
    {
        // param i: order of element
        if (i > L.length) // out of range
            return -INT_MAX;
        else return L.data[i-1];
    }
    \end{lstlisting}

    \newpage
    
    \textbf{插入\ 删除}: 最好$O(1)$, 平均/最坏: $O(n)$
    \begin{lstlisting}[style = Cpp]
    // 插入元素
    template <typename T>
    bool ListInsert(T &L, int i, Type e)
    {
        // param i: order of element
        // invalid i
        if (i < 1 || i > L.maxsize || L.length == L.maxsize)
            return false;
        for (int j=L.length; j>=i; j--) // move element [i, length] backward
            L.data[j] = L.data[j-1];
        L.data[i-1] = e; // insert element
        L.length++; // update length
        return true;
    }
    
    // 删除元素
    template <typename T>
    bool ListDelete(T &L, int i, Type &e)
    {
        // param i: order of element
        if (i < 1 || i > L.length) // invalid i
            return false;
        e = L.data[i-1]; // save deleting element
        for (int j=i; j<L.length; j++) // move element[i+1, length] forward
            L.data[j-1] = L.data[j];
        L.length--; // update length
        return true;
    }
    \end{lstlisting}

    \vspace{-0.5\baselineskip}
    \textbf{表长\ 打印\ 判空}
    \begin{lstlisting}[style = Cpp]
    template <typename T> // 表长
    int Length(T L)
    {
        return L.length;
    }
    
    template <typename T> // 打印表
    void PrintList(T L)
    {
        for (int i=0; i<L.length; i++)
            cout << L.data[i] << " ";
        cout << endl;
    }
    
    template <typename T> // 判空
    bool Empty(T L)
    {
        return (L.length == 0);
    }
    \end{lstlisting}


\newpage
\subsection{线性表的链式表示\ 链表}

\subsubsection{单链表}

    \textbf{单链表}: 线性表的链式存储. 通过一组任意的存储单元来存储线性表中的数据元素. 对每个链表节点, 存放一个\textbf{指向后继的指针}. 单链表结点结构: \verb|data: 数据域, 存数据; next: 指针域, 存后继地址|

    单链表的元素离散分布, 属于\textbf{非随机存取的存储结构}. 通常用头指针 \verb|L|或者 \verb|head|标识单链表, 指出链表的起始地址
    
    \textbf{链表为空表}: 不带头结点: \verb|L == nullptr|; 带头结点 \verb|L->next ==nullptr|

    \textbf{头结点}: 在单链表第一个数据节点之前附加的结点; \textbf{首元结点}: 第一个数据结点

    \textbf{引入头结点的优势}: 1) 链表第一个位置上的操作和其他位置上的操作一致, 无需特殊处理; 2) 无论链表是否为空, 头指针都是指向头结点的非空指针, 统一空表和非空表的处理.

    \textbf{结构}
    \begin{lstlisting}[style = Cpp]
    typedef struct LNode{
        Type data;
        LNode* next;
    }LNode, *LinkList;
    \end{lstlisting}

    \textbf{初始化表}
    \begin{lstlisting}[style = Cpp]
    // 带头结点
    bool InitList(LinkList &L)
    {
        L = new LNode;
        L->next = nullptr;
        return true;
    }

    // 不带头结点
    bool Initial_nohead(LinkList &L)
    {
        L = nullptr;
        return true;
    }
    \end{lstlisting}
    
    \newpage
    \textbf{求表长\ 打印\ 判空}\ 求表长: $O(n)$
    \begin{lstlisting}[style = Cpp]
    int Length(LinkList L)
    {
        int n {0};
        LNode *p = L->next;
        while (p->next != nullptr)
        {
            n++;
            p = p->next;
        }
        return n;
    }
    
    void Print(LinkList L)
    {
        LNode *p = L->next;
        while (p)
        {
            cout << p->data << " -> ";
            p = p->next;
        }
        cout << "end" << endl;
    }
    
    bool Empty(LinkList L)
    {
        if (L->next) return false;
        else return true;
    }
    \end{lstlisting}

    \newpage
    \textbf{查找} $O(n)$
    \begin{lstlisting}[style = Cpp]
    // 按位查询
    LNode* GetElem(LinkList L, int n)
    {
        /*
        n : 位序
        */
        int i {0}; // 头结点计数为0
        LNode* p = L;
        while (p && i < n)
        {
            p = p->next;
            i++;
        }
        return p;
    }
    
    // 按值查询
    LNode* LocateElem(LinkList L, Type x)
    {
        /*
        返回目标结点指针
        找不到则返回空指针
        */
        LNode* p = L->next;
        while (p && p->data != x)
            p = p->next;
        return p;
    }
    \end{lstlisting}

    \newpage
    \textbf{后插}\ 给定位序: $O(n)$; 给定结点指针: $O(1)$
    \begin{lstlisting}[style = Cpp]
    // 给定位序
    bool ListInsert_backward(LinkList &L, int n, Type x)
    {
        int i {0};
        LNode *p = L;
        // find n
        while (p && i < n)
        {
            p = p->next;
            i++;
        }
        if (p)
        {
            LNode *node = new LNode;
            node->data = x;
            node->next = p->next;
            p->next = node;
            return true;
        }
        else return false;
    }
    
    // 给定结点
    bool ListInsert_backward_node(LNode* node, Type x)
    {
        if (node)
        {
            LNode *p = new LNode;
            p->data = x;
            p->next = node->next;
            node->next = p;
            return true;
        }
        else return false;
    }
    \end{lstlisting}

    \newpage
    \textbf{前插}\ 给定位序: $O(n)$; 给定结点指针: $O(1)$
    \begin{lstlisting}[style = Cpp]
    // 给定位序
    bool ListInsert_forward(LinkList &L, int n, Type x)
    {
        int i {0};
        LNode* p = L;
        // find n-1 
        while(p->next && i < n-1)
        {
            p = p->next;
            i++;
        }
        if (p->next)
        {
            // new node
            LNode *node = new LNode;
            node->data = x;   
            // modify pointer
            node->next = p->next;
            p->next = node;
            return true;
        }
        else return false;
    }
    
    // 给定结点
    bool ListInsert_forward_node(LNode* node, Type x)
    {
        if (node)
        {
            LNode* s = new LNode;
            s->data = x;
            s->next = node->next;
            node->next = s;
            // swap data
            Type t = node->data;
            node->data = s->data;
            s->data = t;
            return true;
        }
        else return false;
    }
    \end{lstlisting}

    \newpage
    \textbf{删除结点}
    \begin{lstlisting}[style = Cpp]
    // 给定位序
    bool ListDelete(LinkList &L, int n, Type &e)
    {
        /*
        delete n-th node
        copy data to e
        */
        int i {0};
        LNode *p = L;
        // find n - 1
        while (p && i < n-1)
        {
            p = p->next;
            i++;
        }
        if (p->next && i == n-1)
        {
            LNode *t = p->next;
            p->next = t->next;
            e = t->data;
            delete t;
            return true;   
        }
        else return false;
    }
    \end{lstlisting}

    \textbf{销毁表}
    \begin{lstlisting}[style = Cpp]
    bool ListDestroy(LinkList &L)
    {
        /*
        retain head node
        */
        LNode *p = L->next;
        LNode *q;
        while (p)
        {
            q = p->next;
            delete p;
            p = q;
        }
        L->next = nullptr;
        return true;
    }
    \end{lstlisting}

    \newpage
    \textbf{头插法建立单链表}\ 插入一个结点$O(1)$, 表长为$n$, 总计$O(n)$. 链表元素顺序与读入相反, 可用于\textbf{逆置链表}.
    \begin{lstlisting}[style = Cpp]
    LinkList BuildList_HeadInsert(Type x[], int n)
    {
        LNode *L = new LNode;
        L->next = nullptr;
        for(int i=0; i<n; ++i)
        {
            LNode *s = new LNode;
            s->data = x[i];
            s->next = L->next;
            L->next = s;
        }
        return L;
    }
    \end{lstlisting}

    \textbf{尾插法建立单链表} $O(n)$. 需要附设一个尾指针 \verb|r|; 链表元素顺序与读入顺序相同
    \begin{lstlisting}[style = Cpp]
    LinkList BuildList_TailInsert(Type x[], int n)
    {
        LNode *L = new LNode;
        LNode *end = L;
        for (int i=0; i<n; ++i)
        {
            LNode *s = new LNode;
            s->data = x[i];
            end->next = s;
            end = s;
        }
        end->next = nullptr;
        return L;
    }
    \end{lstlisting}

\newpage
\subsubsection{双链表}

    \textbf{双链表}: 在单链表的基础上增加一个指针, 共有两个指针 \verb|prior, next|, 分别指向前驱和后继.

    \textbf{结构}
    \begin{lstlisting}[style = Cpp]
    typedef struct DNode{
        Type data;
        DNode *prior, *next;
    }DNode, *DLinkList;
    \end{lstlisting}

    \textbf{初始化}
    \begin{lstlisting}[style = Cpp]
    bool Initial_Dlink(DLinkList &L)
    {
        DNode* head = new DNode;
        head->data = 0;
        head->prior = nullptr;
        head->next = nullptr;
        L = head;
        return true;
    }
    \end{lstlisting}

    % new two columns
    \begin{center}
    \begin{minipage}[t]{0.48\textwidth}
    %\begin{center}
        \textbf{前插}\ 给定位序: $O(n)$; 给定结点指针: $O(1)$
        \begin{lstlisting}[style = Cpp]
        bool ListInsert_forward(DLinkList &L, int n, Type x)
        {
            if (n < 1) return false; // n out of range
            DNode* node = new DNode;
            node->data = x;
            // handle n = 1 and list's length = 0
            if (!(L->next) && n == 1)
            {
                node->next = nullptr;
                node->prior = L;   
                L->next = node;
                return true;
            }
            DNode* p = L->next;
            int i {1};
            // search n-th node
            while (i < n && p)
            {
                p = p->next;
                i++;
            }
            if (i < n || !p) return false; // n out of range
            // insert forward
            p = p->prior; // point to previous node, n-1
            node->next = p->next;
            node->prior = p;
            p->next->prior = node;
            p->next = node;
            
            return true;
        }
        
        bool ListInsert_forward_node(DNode* node, Type x)
        {
            /*
            NOT allow inserting node before head node
            */
            if (!(node->prior)) return false; // node is head node
            DNode* p = new DNode;
            p->data = x;
            p->next = node;
            p->prior = node->prior;
            node->prior->next = p;
            node->prior = p;
        
            return true;
        }
        \end{lstlisting}
    %\end{center}
    \end{minipage}
    \begin{minipage}[t]{0.48\textwidth}
    %\begin{center}
        \textbf{后插}\ 给定位序: $O(n)$; 给定结点指针: $O(1)$
        \begin{lstlisting}[style = Cpp]
        bool ListInsert_backward(DLinkList &L, int n, Type x)
        {
            if (n < 0) return false; // n out of range
            DNode* node = new DNode;
            node->data = x;
            // handle n == 0 and list's length = 0
            if (n == 0 && !(L->next))
            {
                node->next = nullptr;
                node->prior = L;
                L->next = node;
            }
            DNode* p = L->next;
            int i {1};
            // search n-th node
            while (i < n && p)
            {
                p = p->next;
                i++;
            }
            // n out of range
            if (i < n || p == L) return false;
            node->next = p->next;
            node->prior = p;
            p->next->prior = node;
            p->next = node;
        
            return true;
        }
        
        bool ListInsert_backward_node(DNode* node, Type x)
        {
            DNode* p = new DNode;
            p->data = x;
            p->next = node->next;
            p->prior = node;
            node->next->prior = p;
            node->next = p;
        
            return true;
        }
        \end{lstlisting}
    %\end{center}
    \end{minipage}
    \end{center}
    
    \newpage
    \textbf{删除结点}\ 给定位序: $O(n)$; 给定结点指针: $O(1)$
    \begin{lstlisting}[style = Cpp]
    bool ListDelete(DLinkList &L, int n)
    {
        if (n < 1) return false; // n out of range
        DNode* p = L->next;
        int i{1};
        while (i < n && p)
        {
            p = p->next;
            i++;
        }
        // n out of range
        if (i < n || !p) return false;
        p->next->prior = p->prior;
        p->prior->next = p->next;
        delete p;
    
        return true;
    }
    \end{lstlisting}

    \textbf{前向遍历} 
    \begin{lstlisting}[style = Cpp]
    void traverse_forward(DNode* node)
    {
        /*
        skip head node
        */
        DNode* p = node;
        while (p)
        {
            if (!(p->prior)) break;; // access head node; if allow to access head node, omment out this line
            cout << p->data << " ; ";
            p = p->prior;
        }
        cout << "end" << endl;
    }
    \end{lstlisting}

    \textbf{后向遍历}
    \begin{lstlisting}[style = Cpp]
    void traverse_backward(DNode* node)
    {
        /* skip head node */
        DNode* p = node;
        while (p)
        {
            if (!(p->prior)) p = p->next; // access head node; if allow to access head node, comment out this line
            cout << p->data << " ; ";
            p = p->next;
        }
        cout << "end" << endl;
    }
    \end{lstlisting}

\newpage
\subsubsection{循环单链表}

    将尾结点的 \verb|next|指向头结点. 若设置尾指针, 则在表头和表尾插入元素均只需要$O(1)$; 设置头指针, 表头插入$O(1)$, 表尾插入$O(n)$

    \textbf{判空}: \verb|L->next ==L|; \textbf{判尾结点}: \verb|p->next ==L|

\subsubsection{循环双链表}

    头结点的 \verb|prior|指向尾结点, 尾结点的 \verb|next|指向头结点.

    \textbf{判空}: \verb|L->next == L && L->prior == L|; \textbf{判尾结点}: \verb|p->next == L|

\subsection{静态链表}

    \textbf{静态链表}: 用数组来表述线性表的链式存储结构. 
    
    结点结构: \verb|data: 数据域; next: 指针域|, 其中, next称为\textbf{游标}, 指向下一个元素的数组下标, 尾结点的 \verb|next = -1|. 空闲元素的 \verb|next = -2|

    适用: 1) 不支持指针的语言; 2) 数据元素数量不变(EX. 文件分配表FAT)

    优点: 1) 增删不需要移动大量元素

    缺点: 1) 容量固定; 2) 无随机存取性

    \textbf{结构}
    \begin{lstlisting}[style = Cpp]
    typedef struct
    {
        Type data;
        int next; // next: >0: pointer; -1: end of list; -2: available node
        int size;
    }SNode, *SLinkList;
    \end{lstlisting}

    \textbf{初始化表}
    \begin{lstlisting}[style = Cpp]
    bool Initial_SLinkList(SLinkList &L, int capacity)
    {
        L = new SNode[capacity];
        if (!L) return false; // not enough memory
        for (int i=0; i<capacity; i++) L[i].next = -2; // initial next field
        L[0].next = -1; // head node
        L->size = capacity;
        return true;
    }
    \end{lstlisting}

    \newpage

    % new two columns
    \begin{center}
    \begin{minipage}[t]{0.48\textwidth}
    %\begin{center}
        \textbf{插入结点} $T(n) = O(n)$
        \begin{lstlisting}[style = Cpp]
        bool SListInsert(SLinkList &L, int n, Type x)
        {
            if (n < 1) return false; // n out of range
            // find available node
            int node {-1};
            for (int i=1; i<L->size; i++)
            {
                if (L[i].next == -2) { node = i; break; }
            }
            if (node == -1) return false; // full list
            // find n-1 node 
            int prior {0}; int idx {0};
            while (idx < n - 1 && prior != -1)
            {
                prior = L[prior].next;
                idx++;
            }
            // invalid n
            if (idx < n - 1) return false; // invalid n
        
            // modify next and data field
            L[node].data = x;
            L[node].next = L[prior].next;
            L[prior].next = node;
        
            return true;
        }
        \end{lstlisting}
    %\end{center}
    \end{minipage}
    \begin{minipage}[t]{0.48\textwidth}
    %\begin{center}
        \textbf{删除结点} $T(n) = O(n)$
        \begin{lstlisting}[style = Cpp]
        bool SListDelete(SLinkList &L, int n)
        {
            // n out of range
            if (n < 1) return false;
            // find n-1
            int prior {0}; int cur = L[prior].next;
            int idx {0}; // order of prior
            while (idx < n-1 && prior != -1)
            {
                prior = cur;
                cur = L[cur].next;
                idx++;
            }
            // invalid n
            if (idx < n - 1 || prior == -1) return false; 
            // modify pointer field in prior
            L[prior].next = L[cur].next;
            // delete n node
            L[cur].next = -2; 
        
            return true;
        }
        \end{lstlisting}
    %\end{center}
    \end{minipage}
    \end{center}

    \textbf{打印表}
    \begin{lstlisting}[style = Cpp]
    void Print_SList(SLinkList L)
    {
        cout << "-----Details of List-----" << endl;
        cout << "format: Data (next)" << endl;
        string data; int next;
        for (int i=0; i<L->size; i++)
        {
            next = L[i].next;
            data = next != -2 ? to_string(L[i].data) : "none";
            cout << data << "(" << next << ")" << " -> ";
        }
        cout << "end" << endl;
        cout << "-----order output-----" << endl;
        int p = L[0].next;
        while (p != -1)
        {
            cout << L[p].data << " -> ";
            p = L[p].next;
        }
        cout << "end" << endl;
    }
    \end{lstlisting}
    

\newpage
\subsection{顺序表和链表的比较}

    \textbf{比较两种数据结构}: 1) 逻辑结构; 2) 物理结构; 3) 运算(创销增删查改)

    \textbf{存取}: 顺序表可以顺序存取和随机存取; 链表只能顺序存取

    \textbf{逻辑结构与物理结构}: 顺序表: 逻辑相邻物理相邻; 链表: 逻辑相邻物理不一定相邻

    \textbf{数据运算}: \textbf{查找}: 链表: $O(n)$; 顺序表: 有序$O(n\log^n)$, 无序$O(n)$; \textbf{插入删除}: 顺序表需要移动元素, $O(n)$; 链表视情况而定, 时间复杂度主要在定位到目标结点上. 

    \textbf{存储空间分配}: 顺序表的元素数量不能超出预先分配的大小, 动态扩增顺序表大小会带来大量时间开销, 且内存中若无足够连续空间, 会导致扩增失败; 链表可以在需要时申请空间, 但存储密度较低. 

    \textbf{选用考量}: 1) \textbf{存储}: 难以估计长度, 使用链表; 2) \textbf{运算}: 若经常\textbf{按位查找/按序号查找(业务场景偏向静态)}: 顺序表; 经常\textbf{插入删除(业务场景偏向动态)}: 链表.

\end{sloppy}
\end{document}