\documentclass[../../DS]{subfiles}

\begin{document}
\begin{sloppy}

\section{栈}

    \textbf{栈}: 受限的线性表, \textbf{只允许在一端进行插入删除}的\textbf{线性表}. \textbf{栈顶}: 允许进行插入删除的一端; \textbf{栈底}: 固定的, 不允许进行插入删除; \textbf{空栈}: 不含任何元素的空表. 操作特性: \textbf{后进先出, Last In First Out, LIFO}

    \textbf{卡特兰数}: 当n个不同元素进栈时, 出栈的可能序列有$\frac{1}{n+1} \binom{2n}{n}$.

    \textbf{栈的基本操作}
    \begin{lstlisting}[style = Cpp]
    bool InitialStack(SqStack &s); // 初始化栈
    bool StackEmpty(SqStack s); // 判断栈是否为空
    bool Push(SqStack &s, Type x); // 将x压入栈顶
    bool Pop(SqStack &s, Type &x); // 从栈顶弹出元素, 用x返回
    bool GetTop(SqStack s, Type &x); // 读取栈顶元素, 非空则用x返回
    bool DestroyStack(SqStack &s); // 销毁栈
    \end{lstlisting}

    \textbf{顺序栈结构}
    \begin{lstlisting}[style = Cpp]
    typedef struct{
        Type data[MAXSIZE]; // 元素
        int top;            // 栈顶指针
    }SqStack;
    \end{lstlisting}

    \textbf{顺序栈基本操作}
    \begin{lstlisting}[style = Cpp]
    // 初始化栈
    bool InitialStack(SqStack &s)
    {
        s.top = -1;
        return true;
    }
    
    // 判断栈是否为空
    bool StackEmpty(SqStack s)
    {
        return s.top == -1;
    }
    
    // 将x压入栈顶
    bool Push(SqStack &s, Type x)
    {
        if (s.top == MAXSIZE) return false; // full stack
        s.data[++s.top] = x;
        return true;
    }
    
    // 从栈顶弹出元素, 用x返回
    bool Pop(SqStack &s, Type &x)
    {
        if (s.top == -1) return false; // empty stack
        x = s.data[s.top--];
        return true;
    }
    
    // 读取栈顶元素, 非空则用x返回
    bool GetTop(SqStack s, Type &x)
    {
        if (s.top == -1) return false; // empty satck
        x = s.data[s.top];
        return true;
    }
    \end{lstlisting}

    s.top为顺序栈的栈顶指针, 初始化时有s.top=-1和s.top=0两种初始化方法, 两种初始化方法的入栈, 出栈, 判空, 判满操作不同. 

    \begin{center}
        \begin{tabular}{|c|c|c|}
            \hline
            {} & s.top = -1 & s.top = 0 \\
            \hline
            入栈 & s.data[++s.top] = x & s.data[s.top++] = x \\ 
            出栈 & x = s.data[s.top--] & x = s.data[--s.top] \\
            判空 & s.top == -1 & s.top == 0 \\
            判满 & s.top == MAXSIZE - 1 & s.top == MAXSIZE \\
            \hline
            \end{tabular}
    \end{center}
    
    \textbf{共享栈}: 同一块连续内存区域M[0...MAXSIZE-1], M[0]时栈0的栈底, M[MAXSIZE-1]是栈1的栈底. 

    判栈空: 栈0: \verb|top0 == -1|; 栈1: \verb|top1 == MAXSIZE|

    入栈: 栈0: \verb|data[++top0] = x|; 栈1: \verb|data[--top1] = x|

    出栈: 栈0: \verb|x = data[top0--]|; 栈1: \verb|x = data[top1++]|

    栈满: \verb|top1 - top0 == 1|

    共享栈是为了更好地利用空间, 只有在整个存储空间都满时才会发生上溢. 存取的T(n) = O(1). 共享栈减少了上溢的可能性, 相比于两个栈独自分配空间, 共享栈合并了两个栈的空间, 相比于独立空间更大, 因此, 一个栈可以使用另一个栈的存储空间, 减少了上溢的可能性.

    \textbf{上溢}: 存储区域满但继续写入, 浮点数中过大设为正无穷; \textbf{下溢}: 存储区域已空仍弹出元素, 浮点数中过小归零

    \textbf{链栈}

    \textbf{链栈结构}
    \begin{lstlisting}[style = Cpp]
    typedef struct LinkNode{
        Type data; // 数据域
        struct LinkNode *front, *rear; // 头尾指针
    }LinkNode, LiStack;
    \end{lstlisting}

    链栈不存在栈满上溢的情况, 并规定\textbf{所有的操作都在单链表的表头进行}, 通常链栈不设置头结点. \verb|head|指向栈顶, 表尾为栈底. 因此, 入栈出栈操作即在单链表的头结点前插入结点或释放当前头结点.

\newpage
\section{队列}

    队列(Queue), 简称队, 一种操作受限的线性表, 只允许\textbf{在表的一端插入, 在另一端删除}. 插入元素: 入队, 删除元素: 出队. \textbf{先进先出, First In First Out, FIFO}

    \textbf{队头(front), 队首}: 允许删除的一端; \textbf{队尾(rear)}: 允许插入的一端; 空队列

    \textbf{顺序存储结构}

    \begin{lstlisting}[style = Cpp]
    typedef struct{
        Type data[MAXSIZE];
        int front, rear; // 队头和队尾指针
    } SqQueue;
    \end{lstlisting}

    \textbf{基本操作}

    \begin{lstlisting}[style = Cpp]
    bool InitQueue(SqQueue &Q); // 初始化队列
    bool QueueEmoty(SqQueue Q); // 判断队空
    bool EnQueue(SqQueue &Q, Type x); // 元素x入队
    bool DeQueue(SqQueue &Q, Type &x); // 元素出队并用x返回
    bool GetHead(SqQueue Q, Type &x); // 读取队头元素并用x返回
    \end{lstlisting}

    \subsection{顺序队列}

    会假溢出, 几乎不用. 
    
    初始化: \verb|Q.front = 0; Q.rear = 0;| 入队: \verb|Q.data[Q.rear++] = x| 出队: \verb|x =Q.data[Q.front++]|

    不能使用 \verb|Q.rear == MAXSIZE| 来判断队满, 只要累计入队次数达到MAXSIZE, Q.rear就会指向MAXSIZE, 造成假溢出.

    \subsection{循环队列}

    存储上与顺序队列一致, 操作上增加对MAXSIZE的取余操作使得在逻辑上将队列视作环状.\\
    初始化: \verb|Q.front = 0; Q.rear = 0;| \\
    队头指针加一: \verb|Q.front = (Q.front + 1) % MAXSIZE| \\
    队尾指针加一: \verb|Q.rear = (Q.rear + 1) % MAXSIZE| \\
    队列长度: \verb|(Q.rear + MAXSIZE - Q.front) % MAXSIZE|  (Q.rear + MAXSIZE使得rear在数值上大于front, 再取余数保留rear和front差值的绝对值大小)

    使用顺序表的处理思路, 会出现初始化和队满时均有 \verb|Q.rear == Q.front|, 因此该条件不能判断队满, 判断队满有3种思路:

    (1) \textbf{闲置一个存储单元}来区分队空和队满, 队列可用长度-1, 较常用.  \\
    \textbf{队满}: \verb|(Q.rear + 1) % MAXSIZE == Q.front| \\
    \textbf{队空}: \verb|Q.rear == Q.front| \\
    \textbf{队中元素个数}: \verb|(Q.rear + MAXSIZE - Q.front) % MAXSIZE|

    (2) \textbf{结构体中增加成员size}, 初始化为0, 插入成功+1, 删除成功-1. \\
    \textbf{队满}: \verb|size == MAXSIZE| \\
    \textbf{队空}: \verb|size == 0| \\
    该方案中, 队满队空都可能出现 \verb|Q.rear == Q.front| 

    (3) \textbf{结构体中增加标志位tag}, 删除成功置0, 插入成果置1. \\
    \textbf{队满}: \verb|tag == 1 && Q.rear == Q.front| \\
    \textbf{队空}: \verb|tag == 0 && Q.rear == Q.front|
    
    \textbf{基本操作}

    \begin{lstlisting}[style = Cpp]
    // 初始化队列
    bool InitQueue(SqQueue &Q)
    {
        Q.front = Q.rear = 0;
        return true;
    }
    
    // 判断队空
    bool QueueEmpty(SqQueue Q)
    {
        return  Q.rear == Q.front;
    }
    
    // 元素x入队
    bool EnQueue(SqQueue &Q, Type x)
    {
        // if full
        if ((Q.rear + 1) % MAXSIZE == Q.front) return false;
        Q.data[Q.rear] = x; // enqueue
        Q.rear = (Q.rear + 1) % MAXSIZE; // update pointer
        return true;
    }
    
    // 元素出队并用x返回
    bool DeQueue(SqQueue &Q, Type &x)
    {
        // if empty
        if (Q.front == Q.rear) return false;
        x = Q.data[Q.front];
        Q.front = (Q.front + 1) % MAXSIZE; //  update pointer
        return true;
    }
    
    // 读取队头元素并用x返回
    bool GetHead(SqQueue Q, Type &x)
    {
        // if empty 
        if (Q.front == Q.rear) return false;
        x = Q.data[Q.front];
        return true;
    }
    \end{lstlisting}

\newpage    
\subsection{链队列}

    通常将链队列设计为一个\textbf{带头结点的单链表}, 并追踪头结点指针和尾结点指针. 适合数据元素变动较大的情形, 不存在队满且溢出的问题.

    \textbf{链队列结构}

    \begin{lstlisting}[style = Cpp]
    typedef struct LinkNode{
        Type data;
        struct LinkNode *next;
    } LinkNode;
    
    typedef struct LinkQueue{
        LinkNode *front, *rear;
    } LinkQueue;
    \end{lstlisting}

    \textbf{基本操作}

    \begin{lstlisting}[style = Cpp]
    // 初始化
    bool InitQueue(LinkQueue &Q)
    {
        LinkNode *head = new LinkNode;
        if (!head) return false; // not enough memory 
        head->next = nullptr;
        Q.front = Q.rear = head;
        return true;
    }
    
    // 判空
    bool QueueEmpty(LinkQueue Q)
    {
        return (Q.rear == Q.front);
    }
    
    // 元素x入队
    bool EnQueue(LinkQueue &Q, Type x)
    {
        LinkNode *node = new LinkNode;
        // new node
        if (!node) return false; // memory fail to allocate
        node->data = x;
        node->next = nullptr;
        // modify pointer
        Q.rear->next = node;
        Q.rear = node;
        return true;
    }
    





    // 出队, 并用x返回
    bool DeQueue(LinkQueue &Q, Type &x)
    {
        // if empty
        if (QueueEmpty(Q)) return false;
        LinkNode *p = Q.rear->next;
        x = p->data;
        // release node
        Q.rear->next = p->next;
        if (Q.rear == p) Q.rear = Q.front; // only one data node
        delete p;
        return true;
    }
    \end{lstlisting}

\subsection{双端队列}

    两端都可以输入和输出的队列. \\
    \textbf{输入受限}的双端队列: 只能一端输入, 两端都能删除. \\
    \textbf{输出受限}的双端队列: 只能一端删除, 两端都能插入.
    
    一般考察输出顺序是否合法, 一个元素在输出时, 主要考察输入输出顺序是否合法. 先将输入序列分为可以立刻输入输出的部分和输入后延迟输出的部分, 延迟输出的部分写出输出顺序, 按照输入序列从早到晚判断是否合法. \\
    EX. 输入受限. 输入: 1 2 3 4 5. 输出: 4 2 1 3 5 合法. 5输入后立刻输出. 右边输出的输出顺序: 3124, Inp1, RInp2, LInp3, RInp 4. \\
    输出: 4 1 3 2 5 非法. 5输入后立刻输出, 右边输出的输出顺序: 2314, Inp1, LInp2, 3不能插入1 2之间, 非法 \\

\newpage
\subsection{栈和队列的应用}

\subsubsection{括号匹配}

    利用栈实现匹配: 
    \begin{verbatim}
    1. 初始化一个空栈; 
    2. 遇到左括号, 入栈; 
    3. 遇到右括号:
        (1) 栈顶为匹配的左括号, 出栈, 找到一个匹配对; 
        (2) 栈顶非匹配的左括号或栈空(EX. [ ) ), 非法序列结束. 
    4. 序列读入完: (1) 栈空, 匹配; (2) 栈非空, 不匹配
    \end{verbatim}

    \begin{lstlisting}[style = Cpp]
    bool bracket_pair(std::string s)
    {   
        using namespace std;
        // initial stack
        SqStack stack;
        InitialStack(stack);
        vector <char> lbrackets {'(', '[', '{'};
        vector <char> rbrackets {')', ']', '}'};
        char e;
    
        for (char c : s)
        {
            auto it = find(lbrackets.begin(), lbrackets.end(), c);
            // left bracket
            if (it != lbrackets.end()) Push(stack, c); // push in stack
            // right brackt
            else {
                auto it = find(rbrackets.begin(), rbrackets.end(), c);
                if (it == rbrackets.end()) continue; // not a bracket
                GetTop(stack, e);
                // pair bracket
                if (c == ')' && e == '(') Pop(stack, e);
                else if (c == ']' && e == '[') Pop(stack, e);
                else if (c == '}' && e == '{') Pop(stack, e);
                else return false; // unpair bracket occur
            }
        }
        if (StackEmpty(stack)) return true;
        else return false;
    }
    // string s1 {"((([([()])])))"}; // true
    // string s2 {"{{[()[]]}}"}; // true
    // string s3 {"[][](]"}; // false
    \end{lstlisting}

\newpage
\subsubsection{算术表达式格式转换}

    前缀表达式和后缀表达式(逆波兰式)不必须要括号, 中缀表达式必须要括号. 前缀和后缀表达式只有操作数和运算符. 前中后缀是符号的前中后缀. 中缀按照可能运算顺序的不同, 可以有多个不同的前缀和后缀表达式\\
    EX. 中缀: \verb|3 + 4 * (2 - 1)|, 前缀: \verb|+ 3 * 4 - 2 1|, 后缀: \verb|3 4 2 1 - * +|

    中缀转前缀: \textbf{先操作符后操作数}, 递归. \verb|3 + 4 * (2 - 1)|, 得 \verb|+ (3) (4 * (2-1))| \\ 
    得到: \verb|+ 3 前缀(4 * (2-1)) -> + 3 * 4 前缀(2 -1) -> + 3 * 4 - 2 1|

    中缀转后缀: \textbf{先操作数后操作符}, 递归. 得 \verb|(3) (4 * (2 -1)) +| \\
    得到: \verb|3 后缀(4 * (2 -1)) + -> 3 4 后缀(2 - 1) * + -> 3 4 2 1 - * +|

    计算机转换为后缀表达式, 使用栈: \\
    依次遍历表达式各字符: \\
        1. 遇到操作数: 直接加入表达式; \\
        2. 遇到括号: 若(, 入栈; 若), 依次弹出栈内各操作符加入运算表达式直至遇到(; \\
        3. 遇到操作符: 若栈顶的操作符优先度更高或相等, 弹出, 直至优先级低于自身(先算优先级高的)或遇到(; 若栈顶优先级低于自身, 自身入栈. \\
    EX. 2 * 3 + (4 * (5 - 2)): \\
    \verb| 2 ->  2  -> 2 3 -> 2 3 * -> 2 3 * -> 2 3 * -> 2 3 * 4 -> 2 3 * 4 -> 2 3 * 4 -> 2 3 * 4 5| \\
    \verb|[ ]-> [*] -> [*] ->  [ ]  ->  [+]  -> [+(]  ->   [+(]  ->   [+(*] ->  [+(*(] -> [+(*(]| \\
    \verb|-> 2 3 * 4 5 -> 2 3 * 4 5 2 -> 2 3 * 4 5 2 - -> 2 3 * 4 5 2 - * -> 2 3 * 4 5 2 - * +|\\
    \verb|->  [+(*(-]  ->    [+(*(-]  ->     [+(*]     ->      [+]        ->      []|

    \begin{lstlisting}[style = Cpp]
    // 123 + 45 * 67 / (89 - 12) * 3 + 456 * (78 - 9) // 123 45 67 * 89 12 - / 3 * + 456 78 9 - * +
    std::string expression_infix2post(std::string e)
    {
        using namespace std;
        string post {""};
        SqStack stack;
        InitialStack(stack);
    
        int n = e.length();
        int begin, end; // split string
        begin = end = 0;
        string temp, top;
        int flag; //0: operator, 1: digit, 2: bracket
    
        vector<char> operators {'+', '-', '*', '/'};
        vector<char> digits {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9'};
        map<string, int> precedence {
            {"+", 1}, {"-", 1}, {"*", 2}, {"/", 2}, };
    
        while (end < n) {
            // split expression 
            auto it = find(operators.begin(), operators.end(), e[end]);
            if (it != operators.end()) { // operator
                temp = e[end]; end++;
                flag = 0;
            }
            else if (e[end] == ' ') { // space
                end++; 
                continue;
            }
            else if (e[end] == '(' || e[end] == ')') { // bracket
                temp = e[end]; end++;
                flag = 2;
            }
            else { //digit
                begin = end;
                while (end < n && find(digits.begin(), digits.end(), e[end]) != digits.end())
                    end++;
                temp = e.substr(begin, end - begin); // (end - 1) - begin + 1
                flag = 1;
            }
    
            // action 
            if (flag == 2) { // bracket
                if (temp == "(") Push(stack, temp);
                else {
                    GetTop(stack, top);
                    while (top != "(") {
                        post += " "; post += top;
                        Pop(stack, top); GetTop(stack, top);
                    } // while
                    Pop(stack, top); // pop '('
                } //else
            }
            else if (flag == 1) { // digit
                post += " "; post += temp;
            }
            else { // operator
                while (!StackEmpty(stack)) {
                    GetTop(stack, top);
                    if (top == "(") break;
                    if (precedence[top] >= precedence[temp]) {
                        post += " "; post += top;
                        Pop(stack, top);
                    }
                    else break;
                }
                Push(stack, temp);      
            }
        }
        // clear stack
        while (!StackEmpty(stack)) {
            Pop(stack, top);
            post += " "; post += top;
        }
        return post;
    }
    \end{lstlisting}

\newpage
\subsubsection{表达式求值}

    \textbf{中缀表达式求值}: 双栈, 操作数栈operand, 操作符栈operator. 
    \begin{verbatim}
    遍历各个字符: 
        1. 如果是数字: 压入operand; 
        2. 如果是括号: 
            (1) 左括号, 压入operator; 
            (2) 按照运算方法, 不断弹出一个操作符, 两个操作数计算, 
                并将结果压入operand, 直到operator栈顶为(, 弹出并抛弃; 
        3. 如果是操作符: 
            (1) operator栈顶优先级高于等于自身, 弹出操作符<op>, 依次弹出两个操作数Y和X, 
                计算X<op>Y, 将结果压入operand; 
            (2) 优先级低于自身, 自身压入operator;
    遍历结束: 
        (1) operator非空, 不断退栈, 按照弹出<op>YX, 压入X<op>Y的原则清理双栈 
        (2) operator空, operand为结果
    \end{verbatim}

    \newpage
    \textbf{后缀表达式求值}: 单栈

    \begin{verbatim}
    遍历各字符:
        1. 如果是操作数, 压入栈;
        2. 如果是操作符<op>, 依次弹出Y和X, 计算X<op>Y并压入栈
    遍历完序列: 栈顶为结果
    \end{verbatim}

    \begin{lstlisting}[style = Cpp]
    // 123 + 45 * 67 / (89 - 12) * 3 + 456 * (78 - 9) // 31704.5
    double calculate_infix(std::string infix)
    {
        using namespace std;
    
        string post = expression_infix2post(infix);
        stack<double> stk;
        int n = post.length();
        string temp;
        double X, Y;
        int begin, end;
        begin = end = 0;
    
        vector<char> operators {'+', '-', '*', '/'};
        vector<char> digits {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9'};
    
        while (end < n) {
            // split expression 
            auto it = find(operators.begin(), operators.end(), post[end]);
            if (it != operators.end()) { // operator
                temp = post[end]; end++;
                Y = stk.top(); stk.pop();
                X = stk.top(); stk.pop();
                if (temp == "+") stk.push(X + Y);
                else if (temp == "-") stk.push(X - Y);
                else if (temp == "*") stk.push(X * Y);
                else if (temp == "/") stk.push(X / Y);
    
            }
            else if (post[end] == ' ') { // space
                end++; 
                continue;
            }
            else { //digit
                begin = end;
                while (end < n && find(digits.begin(), digits.end(), post[end]) != digits.end())
                    end++;
                temp = post.substr(begin, end - begin); // (end - 1) - begin + 1
                stk.push(stod(temp));
            }
        }
        return stk.top();
    }
    \end{lstlisting}
    
\newpage
\section{数组和特殊矩阵}

    \textbf{数组}: n个相同类型元素组成的线性表. \textbf{数组元素}: 每个数据元素. \textbf{下标}: 每个元素在数组中的序号. \textbf{维界}: 下标的取值范围

    \textbf{数组的存储}: A[0...n-1]: $LOC(a_i) = LOC(a_0) + i \times L\ \ (0 \leq i < n)$

    假设: 行下标的范围为$[0...r]$, 列下标的范围为$[0...c]$, 每个数组元素占L字节

    \textbf{行优先}: 第i+1行有j个, 前i行每行c+1列存满. $LOC(a_{i, j}) = LOC(a_{0, 0}) + L \times [(c +1) \times i + j]$

    \textbf{列优先}: 第j+1列有i个, 前j列每列r+1行存满. $LOC(a_{i, j}) = LOC(a_{0, 0}) + L \times [(r + 1) \times j + i]$

\subsection{特殊矩阵压缩存储}

    \textbf{对称矩阵}

    将n阶二维矩阵存储在一维矩阵$B[n(n+1)/2]$

    由于$a_{i, j} = a_{j, i}$, 可以只存储对角线和一个三角部分, 下标无区别. \\
    $a_{i, j}$在一维数组中的序号为: $1 + 2 + \dots + i-1 + j = \frac{i(i-1)}{2} + j$ \\
    对于上三角的元素, 交换i, j可得到相对应的元素下标 \verb|B[k]|.
    % new two columns
    \begin{center}
    \begin{minipage}[t]{0.48\textwidth}
        0-index: 
        \begin{equation*}
            k = \begin{cases}
            \frac{i(i-1)}{2} + j - 1, & i \geq j \mbox{下三角} \\
            \frac{j(j-1)}{2} + i - 1, & i < j \mbox{上三角} \\
            \end{cases}
        \end{equation*}
    \end{minipage}
    \begin{minipage}[t]{0.48\textwidth}
        1-index: 
        \begin{equation*}
            k = \begin{cases}
            \frac{i(i-1)}{2} + j, & i \geq j \mbox{下三角} \\
            \frac{j(j-1)}{2} + i, & i < j \mbox{上三角} \\
            \end{cases}
        \end{equation*}
    \end{minipage}
    \end{center}
    
    \newpage
    \textbf{三角矩阵}

    仅上三角或下三角元素非0, 其余为0, 存储在一维$B[n(n-1)/2 + 1]$
    
    上三角 \\
    $a_{i, j}$在一维数组中的序号为: \\
    $n + (n-1) + \dots + (n - (i - 1) + 1) + (j - i + 1) = \frac{(i-1)(2n-i+2)}{2} + j - i + 1$ \\
    即前i-1行 + 第i行第j个(从对角线i到j)
    % new two columns
    \begin{center}
    \begin{minipage}[t]{0.48\textwidth}
        0-index, B[k]:
        \begin{equation*}
            k = \begin{cases}
            \frac{(i-1)(2n - i + 2)}{2} + j - i, & i \leq j \mbox{上三角} \\
            \frac{n(n-1)}{2}, & i > j \mbox{下三角, 为0} 
            \end{cases}
        \end{equation*}
    \end{minipage}
    \begin{minipage}[t]{0.48\textwidth}
        1-index, B[k]:
        \begin{equation*}
            k = \begin{cases}
            \frac{(i-1)(2n - i + 2)}{2} + j - i + 1, & i \leq j \mbox{上三角} \\
            \frac{n(n-1)}{2} + 1, & i > j \mbox{下三角, 为0} 
            \end{cases}
        \end{equation*}
    \end{minipage}
    \end{center}

    下三角 \\
    $a_{i, j}$在一维数组中的序号为: $1 + 2 + \dots + i-1 + j = \frac{i(i-1)}{2} + j$. 即前i-1行 + 第i行第j个
    % new two columns
    \begin{center}
    \begin{minipage}[t]{0.48\textwidth}
        0-index, B[k]:
        \begin{equation*}
            k = \begin{cases}
            \frac{n(n+1)}{2}, & i \leq j \mbox{上三角} \\
            \frac{i(i-1)}{2} + j - 1, & i > j \mbox{下三角, 为0} 
            \end{cases}
        \end{equation*}
    \end{minipage}
    \begin{minipage}[t]{0.48\textwidth}
        1-index, B[k]:
        \begin{equation*}
            k = \begin{cases}
            \frac{n(n-1)}{2}, & i \leq j \mbox{上三角} \\
            \frac{i(i-1)}{2} + j, & i > j \mbox{下三角, 为0} 
            \end{cases}
        \end{equation*}
    \end{minipage}
    \end{center}
    
    \textbf{三对角矩阵(带状矩阵)}

    对n阶矩阵任意元素$a_{i, j}$, 若$|i-j| > 1,\ a_{i, j} = 0$

    $a_{i, j}$的序号: [前i-1行] + [i行j号]: $[3(i - 1) - 1] + [j - i + 2] = 2i + j - 2$ \\
    故: $a_{i, j}$, \verb|b[[k]|: 0-index: $k = 2i + j - 3$; 1-index: $k = 2i + j - 2$

    从序号反求i, j: 元素在0-index数组的\textbf{下标}为k: $3(i-1) - 1 - 1 < 3(i-1) - 1 \leq k \leq  3i - 1 - 1 < 3i - 1$ \\
    得: $i \leq \frac{k + 1}{3} + 1 \implies i = \lfloor \frac{k + 1}{3} + 1 \rfloor$, 根据 $k = 2i + j - 3$或$k = 2i + j - 2$求出j.

    \textbf{稀疏矩阵}

    非零元素显著少于矩阵元素个数. 使用三元组或十字链表存储.

    三元表: 存储非零元素个数, 矩阵行数和列数, 非零元素详情.

    EX.
    \begin{center}
        \begin{tabular}{|c|c|c|}
            \hline
            i & j & $a_{i, j}$ \\
            \hline
            0 & 6 & 13 \\
            \hline
        \end{tabular}
    \end{center}
    

\end{sloppy}
\end{document}