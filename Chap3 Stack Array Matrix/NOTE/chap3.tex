\documentclass[../../DS]{subfiles}

\begin{document}
\begin{sloppy}

\section{栈}

    \textbf{栈}: 受限的线性表, \textbf{只允许在一端进行插入删除}的\textbf{线性表}. \textbf{栈顶}: 允许进行插入删除的一端; \textbf{栈底}: 固定的, 不允许进行插入删除; \textbf{空栈}: 不含任何元素的空表. 操作特性: \textbf{后进先出, Last In First Out, LIFO}

    \textbf{卡特兰数}: 当n个不同元素进栈时, 出栈的可能序列有$\frac{1}{n+1} \binom{2n}{n}$.

    \textbf{栈的基本操作}
    \begin{lstlisting}[style = Cpp]
    bool InitialStack(SqStack &s); // 初始化栈
    bool StackEmpty(SqStack s); // 判断栈是否为空
    bool Push(SqStack &s, Type x); // 将x压入栈顶
    bool Pop(SqStack &s, Type &x); // 从栈顶弹出元素, 用x返回
    bool GetTop(SqStack s, Type &x); // 读取栈顶元素, 非空则用x返回
    bool DestroyStack(SqStack &s); // 销毁栈
    \end{lstlisting}

    \textbf{顺序栈结构}
    \begin{lstlisting}[style = Cpp]
    typedef struct{
        Type data[MAXSIZE]; // 元素
        int top;            // 栈顶指针
    }SqStack;
    \end{lstlisting}

    \textbf{顺序栈基本操作}
    \begin{lstlisting}[style = Cpp]
    // 初始化栈
    bool InitialStack(SqStack &s)
    {
        s.top = -1;
        return true;
    }
    
    // 判断栈是否为空
    bool StackEmpty(SqStack s)
    {
        return s.top == -1;
    }
    
    // 将x压入栈顶
    bool Push(SqStack &s, Type x)
    {
        if (s.top == MAXSIZE) return false; // full stack
        s.data[++s.top] = x;
        return true;
    }
    
    // 从栈顶弹出元素, 用x返回
    bool Pop(SqStack &s, Type &x)
    {
        if (s.top == -1) return false; // empty stack
        x = s.data[s.top--];
        return true;
    }
    
    // 读取栈顶元素, 非空则用x返回
    bool GetTop(SqStack s, Type &x)
    {
        if (s.top == -1) return false; // empty satck
        x = s.data[s.top];
        return true;
    }
    \end{lstlisting}

    s.top为顺序栈的栈顶指针, 初始化时有s.top=-1和s.top=0两种初始化方法, 两种初始化方法的入栈, 出栈, 判空, 判满操作不同. 

    \begin{center}
        \begin{tabular}{|c|c|c|}
            \toprule
            {} & s.top = -1 & s.top = 0 \\
            \midrule
            入栈 & s.data[++s.top] = x & s.data[s.top++] = x \\ 
            出栈 & x = s.data[s.top--] & x = s.data[--s.top] \\
            判空 & s.top == -1 & s.top == 0 \\
            判满 & s.top == MAXSIZE - 1 & s.top == MAXSIZE \\
            \bottomrule
            \end{tabular}
    \end{center}
    
    \textbf{共享栈}: 同一块连续内存区域M[0...MAXSIZE-1], M[0]时栈0的栈底, M[MAXSIZE-1]是栈1的栈底. 

    判栈空: 栈0: \verb|top0 == -1|; 栈1: \verb|top1 == MAXSIZE|

    入栈: 栈0: \verb|data[++top0] = x|; 栈1: \verb|data[--top1] = x|

    出栈: 栈0: \verb|x = data[top0--]|; 栈1: \verb|x = data[top1++]|

    栈满: \verb|top1 - top0 == 1|

    共享栈是为了更好地利用空间, 只有在整个存储空间都满时才会发生上溢. 存取的T(n) = O(1). 共享栈减少了上溢的可能性, 相比于两个栈独自分配空间, 共享栈合并了两个栈的空间, 相比于独立空间更大, 因此, 一个栈可以使用另一个栈的存储空间, 减少了上溢的可能性.

    \textbf{上溢}: 存储区域满但继续写入, 浮点数中过大设为正无穷; \textbf{下溢}: 存储区域已空仍弹出元素, 浮点数中过小归零

    \textbf{链栈}

    \textbf{链栈结构}
    \begin{lstlisting}[style = Cpp]
    typedef struct{
        Type data; // 数据域
        LinkNode *front, *rear; // 头尾指针
    }LinkNode, LiStack;
    \end{lstlisting}

    链栈不存在栈满上溢的情况, 并规定\textbf{所有的操作都在单链表的表头进行}, 通常链栈不设置头结点. \verb|head|指向栈顶, 表尾为栈底. 因此, 入栈出栈操作即在单链表的头结点前插入结点或释放当前头结点.

\newpage
\section{队列}

    队列(Queue), 简称队, 一种操作受限的线性表, 只允许\textbf{在表的一端插入, 在另一端删除}. 插入元素: 入队, 删除元素: 出队. \textbf{先进先出, First In First Out, FIFO}

    \textbf{队头(front), 队首}: 允许删除的一端; \textbf{队尾(rear)}: 允许插入的一端; 空队列

    \textbf{顺序存储结构}

    \begin{lstlisting}[style = Cpp]
    typedef struct{
        Type data[MAXSIZE];
        int front, rear; // 队头和队尾指针
    } SqQueue;
    \end{lstlisting}

    \textbf{基本操作}

    \begin{lstlisting}[style = Cpp]
    bool InitQueue(SqQueue &Q); // 初始化队列
    bool QueueEmoty(SqQueue Q); // 判断队空
    bool EnQueue(SqQueue &Q, Type x); // 元素x入队
    bool DeQueue(SqQueue &Q, Type &x); // 元素出队并用x返回
    bool GetHead(SqQueue Q, Type &x); // 读取队头元素并用x返回
    \end{lstlisting}

    \subsection{顺序队列}

    会假溢出, 几乎不用. 
    
    初始化: \verb|Q.front = 0; Q.rear = 0;| 入队: \verb|Q.data[Q.rear++] = x| 出队: \verb|x =Q.data[Q.front++]|

    不能使用 \verb|Q.rear == MAXSIZE| 来判断队满, 只要累计入队次数达到MAXSIZE, Q.rear就会指向MAXSIZE, 造成假溢出.

    \subsection{循环队列}

    存储上与顺序队列一致, 操作上增加对MAXSIZE的取余操作使得在逻辑上将队列视作环状.\\
    初始化: \verb|Q.front = 0; Q.rear = 0;| \\
    队头指针加一: \verb|Q.front = (Q.front + 1) % MAXSIZE| \\
    队尾指针加一: \verb|Q.rear = (Q.rear + 1) % MAXSIZE| \\
    队列长度: \verb|(Q.rear + MAXSIZE - Q.front) % MAXSIZE|  (Q.rear + MAXSIZE使得rear在数值上大于front, 再取余数保留rear和front差值的绝对值大小)

    使用顺序表的处理思路, 会出现初始化和队满时均有 \verb|Q.rear == Q.front|, 因此该条件不能判断队满, 判断队满有3种思路:

    (1) \textbf{闲置一个存储单元}来区分队空和队满, 队列可用长度-1, 较常用.  \\
    \textbf{队满}: \verb|(Q.rear + 1) % MAXSIZE == Q.front| \\
    \textbf{队空}: \verb|Q.rear == Q.front| \\
    \textbf{队中元素个数}: \verb|(Q.rear + MAXSIZE - Q.front) % MAXSIZE|

    (2) \textbf{结构体中增加成员size}, 初始化为0, 插入成功+1, 删除成功-1. \\
    \textbf{队满}: \verb|size == MAXSIZE| \\
    \textbf{队空}: \verb|size == 0| \\
    该方案中, 队满队空都可能出现 \verb|Q.rear == Q.front| 

    (3) \textbf{结构体中增加标志位tag}, 删除成功置0, 插入成果置1. \\
    \textbf{队满}: \verb|tag == 1 && Q.rear == Q.front| \\
    \textbf{队空}: \verb|tag == 0 && Q.rear == Q.front|
    
    \textbf{基本操作}

    \begin{lstlisting}[style = Cpp]
    // 初始化队列
    bool InitQueue(SqQueue &Q)
    {
        Q.front = Q.rear = 0;
        return true;
    }
    
    // 判断队空
    bool QueueEmpty(SqQueue Q)
    {
        return  Q.rear == Q.front;
    }
    
    // 元素x入队
    bool EnQueue(SqQueue &Q, Type x)
    {
        // if full
        if ((Q.rear + 1) % MAXSIZE == Q.front) return false;
        Q.data[Q.rear] = x; // enqueue
        Q.rear = (Q.rear + 1) % MAXSIZE; // update pointer
        return true;
    }
    
    // 元素出队并用x返回
    bool DeQueue(SqQueue &Q, Type &x)
    {
        // if empty
        if (Q.front == Q.rear) return false;
        x = Q.data[Q.front];
        Q.front = (Q.front + 1) % MAXSIZE; //  update pointer
        return true;
    }
    
    // 读取队头元素并用x返回
    bool GetHead(SqQueue Q, Type &x)
    {
        // if empty 
        if (Q.front == Q.rear) return false;
        x = Q.data[Q.front];
        return true;
    }
    \end{lstlisting}

\newpage    
\subsection{链队列}

    通常将链队列设计为一个\textbf{带头结点的单链表}, 并追踪头结点指针和尾结点指针. 适合数据元素变动较大的情形, 不存在队满且溢出的问题.

    \textbf{链队列结构}

    \begin{lstlisting}[style = Cpp]
    typedef struct LinkNode{
        Type data;
        struct LinkNode *next;
    } LinkNode;
    
    typedef struct LinkQueue{
        LinkNode *front, *rear;
    } LinkQueue;
    \end{lstlisting}

    \textbf{基本操作}

    \begin{lstlisting}[style = Cpp]
    // 初始化
    bool InitQueue(LinkQueue &Q)
    {
        LinkNode *head = new LinkNode;
        if (!head) return false; // not enough memory 
        head->next = nullptr;
        Q.front = Q.rear = head;
        return true;
    }
    
    // 判空
    bool QueueEmpty(LinkQueue Q)
    {
        return (Q.rear == Q.front);
    }
    
    // 元素x入队
    bool EnQueue(LinkQueue &Q, Type x)
    {
        LinkNode *node = new LinkNode;
        // new node
        if (!node) return false; // memory fail to allocate
        node->data = x;
        node->next = nullptr;
        // modify pointer
        Q.rear->next = node;
        Q.rear = node;
        return true;
    }
    





    // 出队, 并用x返回
    bool DeQueue(LinkQueue &Q, Type &x)
    {
        // if empty
        if (QueueEmpty(Q)) return false;
        LinkNode *p = Q.rear->next;
        x = p->data;
        // release node
        Q.rear->next = p->next;
        if (Q.rear == p) Q.rear = Q.front; // only one data node
        delete p;
        return true;
    }
    \end{lstlisting}

\subsection{双端队列}

    两端都可以输入和输出的队列. \\
    \textbf{输入受限}的双端队列: 只能一端输入, 两端都能删除. \\
    \textbf{输出受限}的双端队列: 只能一端删除, 两端都能插入.
    
    一般考察输出顺序是否合法, 一个元素在输出时, 主要考察输入输出顺序是否合法. 先将输入序列分为可以立刻输入输出的部分和输入后延迟输出的部分, 延迟输出的部分写出输出顺序, 按照输入序列从早到晚判断是否合法. \\
    EX. 输入受限. 输入: 1 2 3 4 5. 输出: 4 2 1 3 5 合法. 5输入后立刻输出. 右边输出的输出顺序: 3124, Inp1, RInp2, LInp3, RInp 4. \\
    输出: 4 1 3 2 5 非法. 5输入后立刻输出, 右边输出的输出顺序: 2314, Inp1, LInp2, 3不能插入1 2之间, 非法 \\
    











    

    
    
    



\end{sloppy}
\end{document}